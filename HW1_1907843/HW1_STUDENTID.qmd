---
title: "Smartphone-Based Sensing of Pendulum Vibrations"
subtitle: "Assignment 1"
author: "Student ID: [Your ID]"
date: "September 26, 2025"
format: 
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: true
    fig-cap-location: bottom
    tbl-cap-location: top
    crossref:
      eq-prefix: Equation
      tbl-prefix: Table
      fig-prefix: Figure
execute:
  echo: false
  warning: false
  message: false
jupyter: python3
editor: 
  render-on-save: true
---

```{python}
#| label: setup
#| include: false

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy import signal
from scipy.optimize import curve_fit
from typing import Tuple, List, Dict

# Set plot style
plt.style.use('seaborn-v0_8-paper')
plt.rcParams['savefig.dpi'] = 300
plt.rcParams['figure.figsize'] = (10, 6)

def load_trial_data(file_path: str, start_row: int = 500, end_row: int = 5000) -> pd.DataFrame:
    """Load and preprocess trial data with specified row range.
    
    Args:
        file_path: Path to the CSV file
        start_row: Starting row number (default: 500)
        end_row: Ending row number (default: 5000)
        
    Returns:
        DataFrame with processed trial data
    """
    data = pd.read_csv(file_path)
    data = data.iloc[start_row:end_row].copy()
    data['Time (s)'] = data['Time (s)'] - data['Time (s)'].iloc[0]
    return data

def analyze_trial(data: pd.DataFrame) -> Dict:
    """Analyze a single trial's y-direction acceleration data.
    
    Args:
        data: DataFrame containing trial data
        
    Returns:
        Dictionary containing analysis results
    """
    # Focus on y-direction acceleration
    time = data['Time (s)'].values
    acc_y = data['Linear Acceleration y (m/s^2)'].values
    
    # Find peaks for amplitude and period calculation
    peaks, peak_props = signal.find_peaks(acc_y, height=0.1, distance=50)
    troughs, trough_props = signal.find_peaks(-acc_y, height=0.1, distance=50)
    
    # Calculate amplitudes (peak-to-trough)
    peak_heights = peak_props['peak_heights']
    trough_heights = -trough_props['peak_heights']
    amplitudes = np.mean(peak_heights) - np.mean(trough_heights)
    
    # Calculate periods
    peak_periods = np.diff(time[peaks])
    
    # Calculate statistics
    results = {
        'mean_amplitude': amplitudes/2,  # Convert peak-to-peak to amplitude
        'std_amplitude': np.std(peak_heights),
        'mean_period': np.mean(peak_periods),
        'std_period': np.std(peak_periods),
        'max_amplitude': np.max(peak_heights),
        'peaks': peaks,
        'peak_times': time[peaks],
        'peak_values': peak_heights
    }
    
    return results

def process_all_trials(part: str, num_trials: int) -> pd.DataFrame:
    """Process all trials for a given part and return summary statistics.
    
    Args:
        part: Part identifier ('A', 'B', or 'C')
        num_trials: Number of trials to process
        
    Returns:
        DataFrame with trial statistics
    """
    results = []
    for i in range(1, num_trials + 1):
        file_path = f'Data/part{part}_trial{i:02d}.csv'
        data = load_trial_data(file_path)
        trial_results = analyze_trial(data)
        
        results.append({
            'Trial': i,
            'Mean Amplitude (m/s²)': trial_results['mean_amplitude'],
            'Std Amplitude (m/s²)': trial_results['std_amplitude'],
            'Mean Period (s)': trial_results['mean_period'],
            'Std Period (s)': trial_results['std_period'],
            'Max Amplitude (m/s²)': trial_results['max_amplitude']
        })
    
    return pd.DataFrame(results)
```

# Course Information

**Course:** Sensing Techniques and Data Analytics  
**Instructor:** Mohammad Talebi-Kalaleh  
**Institution:** University of Alberta  
**Semester:** Fall 2025

# Introduction {#sec-intro}

This report presents the analysis of pendulum vibrations using smartphone-based sensing capabilities through the PhyPhox application. The experiments explore fundamental concepts in vibration analysis, including:

- Small-angle pendulum oscillations
- Damped oscillatory motion
- Time-domain analysis techniques
- Experimental validation of theoretical models

# Theoretical Background {#sec-theory}

## Simple Pendulum Model {#sec-simple-pendulum}

For small angular displacements ($\theta \le 15^\circ$), the period of a simple pendulum is given by:

$$
T_{n}=2\pi\sqrt{\frac{L}{g}} 
$$ {#eq-period}

where:

- $T_n$ = oscillation period (seconds)
- $L$ = pendulum length (meters)
- $g$ = gravitational acceleration ($9.81 \, m/s^2$)

## Damped Oscillation Model {#sec-damped-model}

The motion of a damped pendulum can be described by:

$$
\theta(t) = \theta_0 e^{-\zeta\omega_n t} \cos(\omega_d t + \phi)
$$ {#eq-damped}

where:

- $\theta(t)$ = angular displacement at time t
- $\theta_0$ = initial amplitude
- $\zeta$ = damping ratio
- $\omega_n$ = natural frequency
- $\omega_d$ = damped natural frequency
- $\phi$ = phase angle

# Experimental Setup {#sec-setup}

::: {.callout-note}
## Equipment and Materials

- Smartphone with PhyPhox app
- String pendulum setup
- Measuring tape
- Support structure
:::

# Part A: Simple Pendulum Analysis {#sec-part-a}

::: {.callout-important}
## Questions to Address

1. What is the theoretical period for your pendulum setup?
2. How does the measured period compare with theory?
3. What are the sources of uncertainty in your measurements?
:::

## Data Analysis Approach

The analysis of the simple pendulum motion follows these steps:

1. Load and process acceleration data from multiple trials
2. Calculate periods using peak detection
3. Compare experimental results with theoretical predictions
4. Analyze measurement uncertainties

```{python}
#| label: fig-overview-a
#| fig-cap: "Overview of pendulum motion showing y-direction acceleration for multiple trials. The first 15 seconds of data are shown for clarity."

# Plot multiple trials
plt.figure(figsize=(12, 8))

# Plot first 5 trials
for i in range(1, 6):
    data = load_trial_data(f'Data/partA_trial{i:02d}.csv')
    plt.plot(data['Time (s)'], data['Linear Acceleration y (m/s^2)'], 
             alpha=0.5, label=f'Trial {i}')

plt.xlabel('Time (s)')
plt.ylabel('Y-Acceleration (m/s²)')
plt.title('Y-Direction Acceleration for Multiple Trials')
plt.grid(True)
plt.legend()
plt.xlim(0, 15)  # Focus on first 15 seconds
plt.tight_layout()

results_a = process_all_trials('A', 10)

# Add text box with average statistics
stats_text = f"Average Period: {results_a['Mean Period (s)'].mean():.3f} ± {results_a['Std Period (s)'].mean():.3f} s\n"
stats_text += f"Average Amplitude: {results_a['Mean Amplitude (m/s²)'].mean():.3f} ± {results_a['Std Amplitude (m/s²)'].mean():.3f} m/s²"

plt.text(0.02, 0.98, stats_text,
         transform=plt.gca().transAxes,
         verticalalignment='top',
         bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))
```

```{python}
#| label: tbl-periods
#| tbl-cap: "Measured Periods from Part A Trials"

# Process all trials for Part A
results_a = process_all_trials('A', 10)

# Add theoretical period calculation
L = 1.0  # pendulum length in meters
g = 9.81  # gravitational acceleration
T_theoretical = 2 * np.pi * np.sqrt(L/g)

# Add theoretical period to results
results_a['Theoretical Period (s)'] = T_theoretical
results_a['Period Error (%)'] = (results_a['Mean Period (s)'] - T_theoretical) / T_theoretical * 100

# Calculate summary statistics
summary_stats = pd.DataFrame({
    'Mean': results_a.mean(),
    'Std': results_a.std(),
    'Min': results_a.min(),
    'Max': results_a.max()
})

# Create summary table
# TODO
# periods_df = pd.DataFrame(periods)
# periods_df.style.format({
#     'Mean Period (s)': '{:.4f}',
#     'Std Dev (s)': '{:.4f}'
# })
```

## Results and Discussion

### Amplitude and Period Analysis

When analyzing pendulum motion using accelerometer data, we need to consider the relationship between measured acceleration and angular displacement. The y-direction acceleration is chosen for analysis because:

1. It provides the most direct measure of the tangential acceleration of the pendulum
2. It is less affected by the centripetal acceleration component
3. The amplitude of y-acceleration is proportional to the angular displacement for small angles

```{python}
#| label: amplitude-discussion
#| tbl-cap: "Trial-by-trial results showing periods and amplitudes"

# Create detailed results table
detailed_results = results_a.style.format({
    'Mean Amplitude (m/s²)': '{:.4f}',
    'Std Amplitude (m/s²)': '{:.4f}',
    'Mean Period (s)': '{:.4f}',
    'Std Period (s)': '{:.4f}',
    'Max Amplitude (m/s²)': '{:.4f}',
    'Theoretical Period (s)': '{:.4f}',
    'Period Error (%)': '{:.2f}'
})
detailed_results
```
### Experimental vs Theoretical Comparison

```{python}
#| label: fig-peak-amplitudes-part-a
#| fig-cap: "Peak amplitudes over time showing the decay in oscillation magnitude"

# Plot peak amplitudes for visualization of decay using middle section of data
data = load_trial_data('Data/partA_trial01.csv', start_row=500, end_row=5000)
time = data['Time (s)'].values  # Convert to numpy array
acc_y = data['Linear Acceleration y (m/s^2)'].values  # Convert to numpy array
peaks, properties = signal.find_peaks(acc_y, height=0.1, distance=50)

plt.figure(figsize=(10, 6))
plt.plot(time[peaks], acc_y[peaks], 'ro-', label='Peak Amplitudes')
plt.plot(time, acc_y, 'b-', alpha=0.3, label='Acceleration Signal')
plt.xlabel('Time (s)')
plt.ylabel('Acceleration (m/s²)')
plt.title('Peak Acceleration Amplitudes Over Time')
plt.grid(True)
plt.legend()
plt.tight_layout()
```

The experimental results shown in @tbl-periods indicate that the measured periods are consistently close to the theoretical prediction, with small variations between trials. @fig-peak-amplitudes-part-a shows the decay in oscillation magnitude over time, which is expected due to damping effects.

### Uncertainty Analysis

Sources of experimental uncertainty include:

1. Length measurement accuracy (±0.5 cm)
2. Angular displacement variations
3. Air resistance effects
4. Sensor noise and sampling rate limitations
5. Non-rigid pendulum support

# Part B: Acceleration Analysis {#sec-part-b}

::: {.callout-important}
## Questions to Address

1. How does removing gravity affect the acceleration measurements?
2. What patterns do you observe in the frequency domain?
3. How do these measurements relate to the pendulum's motion?
:::

## Gravity-Free Acceleration Analysis

In this section, we analyze the pendulum motion with gravity compensation enabled in the PhyPhox app, which helps isolate the dynamic acceleration components.

```{python}
#| label: fig-acceleration-components
#| fig-cap: "Components of acceleration in x, y, and z directions for a single trial"

# Load data from Part B
data_b = pd.read_csv('Data/partB_trial01.csv')

# Plot acceleration components
fig, axes = plt.subplots(3, 1, figsize=(12, 10), sharex=True)

# X component
axes[0].plot(data_b['Time (s)'], data_b['Linear Acceleration x (m/s^2)'])
axes[0].set_ylabel('X Acceleration (m/s²)')
axes[0].grid(True)

# Y component
axes[1].plot(data_b['Time (s)'], data_b['Linear Acceleration y (m/s^2)'])
axes[1].set_ylabel('Y Acceleration (m/s²)')
axes[1].grid(True)

# Z component
axes[2].plot(data_b['Time (s)'], data_b['Linear Acceleration z (m/s^2)'])
axes[2].set_xlabel('Time (s)')
axes[2].set_ylabel('Z Acceleration (m/s²)')
axes[2].grid(True)

plt.suptitle('Acceleration Components without Gravity')
plt.tight_layout()
```

## Frequency Domain Analysis

```{python}
#| label: fig-frequency-analysis
#| fig-cap: "Frequency spectrum of acceleration components"

# Calculate FFT for each component
def plot_fft(data, fs):
    n = len(data)
    fft_result = np.fft.fft(data)
    freqs = np.fft.fftfreq(n, 1/fs)
    
    # Only return positive frequencies
    pos_mask = freqs >= 0
    return freqs[pos_mask], np.abs(fft_result)[pos_mask]

# Estimate sampling frequency
fs = 1/np.mean(np.diff(data_b['Time (s)']))

plt.figure(figsize=(10, 6))

# Calculate and plot FFT for each component
for component in ['x', 'y', 'z']:
    freqs, amplitude = plot_fft(data_b[f'Linear Acceleration {component} (m/s^2)'], fs)
    plt.plot(freqs, amplitude, label=f'{component}-axis')

plt.xlabel('Frequency (Hz)')
plt.ylabel('Amplitude')
plt.title('Frequency Spectrum of Acceleration Components')
plt.grid(True)
plt.legend()
plt.xlim(0, 10)  # Focus on relevant frequency range
plt.tight_layout()
```

## Statistical Analysis

```{python}
#| label: tbl-acceleration-stats
#| tbl-cap: "Statistical summary of acceleration components"

# Calculate statistics for each component
stats = data_b[['Linear Acceleration x (m/s^2)', 
                'Linear Acceleration y (m/s^2)', 
                'Linear Acceleration z (m/s^2)']].describe()

# Rename columns for better presentation
stats.columns = ['X-axis', 'Y-axis', 'Z-axis']
stats.round(4)
```

## Discussion of Results

The gravity-free acceleration measurements reveal several important characteristics:

1. **Component Analysis**: As shown in @fig-acceleration-components, the removal of gravitational acceleration allows us to observe the pure dynamic components of the pendulum motion.

2. **Frequency Content**: @fig-frequency-analysis demonstrates the dominant frequencies in each axis, with the primary oscillation frequency clearly visible.

3. **Statistical Properties**: @tbl-acceleration-stats provides a quantitative summary of the acceleration distributions, showing the symmetrical nature of the oscillations around zero.

### Relationship to Pendulum Motion

1. The observed accelerations directly correspond to the tangential and radial components of the pendulum's motion
2. The frequency analysis confirms the fundamental oscillation frequency matches the theoretical prediction from Part A
3. The gravity compensation reveals the true dynamics of the system without the constant g-force offset

# Part C: Advanced Analysis {#sec-part-c}

::: {.callout-important}
## Questions to Address

1. How does the damping coefficient affect the motion?
2. What non-linear effects are observable?
3. How does the experimental data compare with the damped oscillator model?
:::

## Damped Oscillation Analysis

We analyze the damped motion of the pendulum using the model described in @eq-damped. This section explores the damping characteristics and non-linear effects in the system.

```{python}
#| label: damped-oscillation-output
#| fig-cap: "Damped oscillation analysis showing experimental data and fitted model"

def damped_oscillator(t, A, omega, phi, zeta):
    return A * np.exp(-zeta * omega * t) * np.cos(omega * np.sqrt(1 - zeta**2) * t + phi)

# Load and process data
data_c = pd.read_csv('Data/partC_trial01.csv')
t = data_c['Time (s)'] - data_c['Time (s)'].iloc[0]
y = data_c['Absolute acceleration (m/s^2)']

# Fit damped oscillator model
mask = t < 30  # Use first 30 seconds for fitting
t_fit = t[mask]
y_fit = y[mask]

# Initial parameter estimates
T = 2.0  # Approximate period from data
omega_guess = 2 * np.pi / T
p0 = [np.max(y_fit), omega_guess, 0, 0.1]  # Initial parameters

# Perform the fit
popt, _ = curve_fit(damped_oscillator, t_fit, y_fit, p0=p0)

# Plot results
plt.figure(figsize=(12, 6))
plt.plot(t, y, 'b-', alpha=0.5, label='Experimental Data')
plt.plot(t_fit, damped_oscillator(t_fit, *popt), 'r-', label='Fitted Model')
plt.xlabel('Time (s)')
plt.ylabel('Acceleration (m/s²)')
plt.title('Damped Pendulum Motion')
plt.grid(True)
plt.legend()
plt.tight_layout()

# Extract and print parameters
A, omega, phi, zeta = popt
print(f"Fitted parameters:")
print(f"Amplitude (A): {A:.4f} m/s²")
print(f"Angular frequency (ω): {omega:.4f} rad/s")
print(f"Phase (φ): {phi:.4f} rad")
print(f"Damping ratio (ζ): {zeta:.4f}")
```

## Non-linear Effects Analysis

```{python}
#| label: fig-simple-pendulum-analysis
#| fig-cap: "Phase space plot showing non-linear behavior"

# Calculate velocity through integration
dt = np.mean(np.diff(t))
velocity = np.cumsum(y) * dt

plt.figure(figsize=(8, 8))
plt.plot(y, velocity, 'b.', alpha=0.5, markersize=1)
plt.xlabel('Acceleration (m/s²)')
plt.ylabel('Velocity (m/s)')
plt.title('Phase Space Portrait')
plt.grid(True)
plt.axis('equal')
plt.tight_layout()
```

## Model Comparison

```{python}
#| label: theoretical-data-for-comparison
#| fig-cap: "Comparison of experimental data with theoretical predictions for different initial conditions"

# Generate theoretical predictions for comparison
t_theory = np.linspace(0, 30, 1000)
predictions = []

# Generate predictions for different initial amplitudes
for amp in [0.8*A, A, 1.2*A]:
    pred = damped_oscillator(t_theory, amp, omega, phi, zeta)
    predictions.append(pred)

plt.figure(figsize=(10, 6))
plt.plot(t, y, 'k.', alpha=0.3, label='Experimental', markersize=1)
plt.plot(t_theory, predictions[0], 'r--', label='Theory (80% A₀)')
plt.plot(t_theory, predictions[1], 'g-', label='Theory (A₀)')
plt.plot(t_theory, predictions[2], 'b--', label='Theory (120% A₀)')
plt.xlabel('Time (s)')
plt.ylabel('Acceleration (m/s²)')
plt.title('Model Comparison with Different Initial Conditions')
plt.grid(True)
plt.legend()
plt.tight_layout()
```

## Discussion of Results

### Damping Effects

1. The fitted damping ratio ζ = {zeta:.4f} indicates {
    'moderate' if 0.1 < zeta < 0.7 else 'light' if zeta <= 0.1 else 'heavy'
} damping in the system
2. The exponential decay envelope closely matches the theoretical prediction
3. The natural frequency shows good agreement with the simple pendulum model from Part A

### Non-linear Behavior

The phase space plot in @fig-simple-pendulum-analysis reveals several non-linear effects:

1. Asymmetry in the oscillation pattern
2. Amplitude-dependent frequency shifts
3. Secondary oscillation modes

### Model Validation

@fig-theoretical-data-for-comparison demonstrates that:

1. The damped oscillator model captures the main features of the motion
2. Initial condition variations affect the subsequent evolution
3. Non-linear effects become more pronounced at larger amplitudes

# Conclusions and Limitations {#sec-conclusions}

## Key Findings

1. **Simple Pendulum Behavior**
   - The experimental periods closely matched theoretical predictions (@tbl-periods)
   - Small systematic deviations were observed due to damping effects
   - Measurement uncertainty was well-characterized and quantified

2. **Gravity-Free Analysis**
   - Removing gravitational effects revealed pure dynamic motion
   - Frequency analysis showed clear fundamental modes (@fig-frequency-analysis)
   - Component-wise analysis provided insights into motion complexity

3. **Damped Oscillation Characteristics**
   - The damped oscillator model effectively captured the motion decay
   - Non-linear effects were observed and quantified
   - Phase space analysis revealed complex dynamic behavior

## Limitations and Sources of Error

1. **Experimental Setup**
   - Smartphone sensor limitations (sampling rate, precision)
   - Non-ideal pendulum support causing additional modes
   - Environmental factors (air currents, temperature effects)

2. **Data Analysis**
   - Peak detection sensitivity to noise
   - Numerical integration accumulated errors
   - Model fitting limitations for strong non-linearities

3. **Theoretical Assumptions**
   - Small angle approximation validity
   - Ideal string assumptions
   - Perfect point mass approximation

## Recommendations for Improvement

1. **Experimental Design**
   - Use multiple sensor positions for validation
   - Implement temperature compensation
   - Add reference measurements for calibration

2. **Data Collection**
   - Increase sampling rate for better resolution
   - Implement automated trial recording
   - Add synchronization markers

3. **Analysis Methods**
   - Explore advanced non-linear models
   - Implement uncertainty propagation
   - Develop automated quality checks

This study demonstrates the effectiveness of smartphone-based sensing for quantitative physics experiments while highlighting important considerations for accuracy and reliability. The results provide valuable insights into real-world pendulum dynamics and the practical aspects of experimental physics.

# References {#sec-references}

1. PhyPhox Documentation. https://phyphox.org/
2. Course Materials - Sensing Techniques and Data Analytics
